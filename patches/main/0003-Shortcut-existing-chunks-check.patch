From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Fri, 8 Nov 2024 22:51:42 +0800
Subject: [PATCH] Shortcut existing chunks check


diff --git a/c2me-rewrites-chunk-system/src/main/java/com/ishland/c2me/rewrites/chunksystem/common/Config.java b/c2me-rewrites-chunk-system/src/main/java/com/ishland/c2me/rewrites/chunksystem/common/Config.java
index d36a387b..be26cd06 100644
--- a/c2me-rewrites-chunk-system/src/main/java/com/ishland/c2me/rewrites/chunksystem/common/Config.java
+++ b/c2me-rewrites-chunk-system/src/main/java/com/ishland/c2me/rewrites/chunksystem/common/Config.java
@@ -44,6 +44,13 @@ public class Config {
                     """)
             .getBoolean(true, false);
 
+    public static final boolean shortcutOptionalChunkRequests = new ConfigSystem.ConfigAccessor()
+            .key("chunkSystem.shortcutOptionalChunkRequests")
+            .comment("""
+                    This option shortcuts optional chunk requests [NF only] [for debugging deadlocks]
+                    """)
+            .getBoolean(false, false);
+
     public static void init() {
         // intentionally empty
     }
diff --git a/c2me-rewrites-chunk-system/src/main/java/com/ishland/c2me/rewrites/chunksystem/mixin/MixinServerChunkManager.java b/c2me-rewrites-chunk-system/src/main/java/com/ishland/c2me/rewrites/chunksystem/mixin/MixinServerChunkManager.java
index c2968495..b7f6f297 100644
--- a/c2me-rewrites-chunk-system/src/main/java/com/ishland/c2me/rewrites/chunksystem/mixin/MixinServerChunkManager.java
+++ b/c2me-rewrites-chunk-system/src/main/java/com/ishland/c2me/rewrites/chunksystem/mixin/MixinServerChunkManager.java
@@ -1,6 +1,7 @@
 package com.ishland.c2me.rewrites.chunksystem.mixin;
 
 import com.ishland.c2me.base.mixin.access.IThreadedAnvilChunkStorage;
+import com.ishland.c2me.rewrites.chunksystem.common.Config;
 import com.llamalad7.mixinextras.injector.wrapoperation.Operation;
 import com.llamalad7.mixinextras.injector.wrapoperation.WrapOperation;
 import net.minecraft.server.world.ChunkHolder;
@@ -36,22 +37,72 @@ public abstract class MixinServerChunkManager {
     @Shadow
     protected abstract @Nullable ChunkHolder getChunkHolder(long pos);
 
+    @Shadow @Final private long[] chunkPosCache;
+
+    @Shadow @Final private ChunkStatus[] chunkStatusCache;
+
+    @Shadow @Final private Chunk[] chunkCache;
+
     @Inject(method = "getChunk(IILnet/minecraft/world/chunk/ChunkStatus;Z)Lnet/minecraft/world/chunk/Chunk;", at = @At("HEAD"), cancellable = true)
     private void shortcutGetChunk(int x, int z, ChunkStatus leastStatus, boolean create, CallbackInfoReturnable<Chunk> cir) {
         if (Thread.currentThread() != this.serverThread) {
-            final ChunkHolder holder = this.getChunkHolder(ChunkPos.toLong(x, z));
-            if (holder != null) {
-                final CompletableFuture<OptionalChunk<Chunk>> future = holder.load(leastStatus, this.chunkLoadingManager); // thread-safe in new system
-                Chunk chunk = future.getNow(ChunkHolder.UNLOADED).orElse(null);
-                if (chunk instanceof WrapperProtoChunk readOnlyChunk) chunk = readOnlyChunk.getWrappedChunk();
-                if (chunk != null) {
-                    cir.setReturnValue(chunk); // also cancels
+            Chunk chunk = this.c2me$fastpathExistingChunks(x, z, leastStatus);
+            if (chunk != null) {
+                cir.setReturnValue(chunk);
+                return;
+            } else {
+                if (Config.shortcutOptionalChunkRequests) {
+                    if (!create) {
+                        cir.setReturnValue(null);
+                        return;
+                    }
+                }
+            }
+        } else { // on server thread
+            if (Config.shortcutOptionalChunkRequests) {
+                if (!create) { // no create required
+                    Chunk chunk = this.c2me$getFromCahe(x, z, leastStatus, false);
+                    if (chunk != null) {
+                        cir.setReturnValue(chunk);
+                    } else {
+                        cir.setReturnValue(this.c2me$fastpathExistingChunks(x, z, leastStatus));
+                    }
                     return;
                 }
             }
         }
     }
 
+    @Unique
+    private Chunk c2me$getFromCahe(int x, int z, ChunkStatus leastStatus, boolean create) {
+        long l = ChunkPos.toLong(x, z);
+
+        if (this.chunkPosCache == null || this.chunkStatusCache == null || this.chunkCache == null) {
+            return null; // no cache
+        }
+
+        for (int i = 0; i < 4; i++) {
+            if (l == this.chunkPosCache[i] && leastStatus == this.chunkStatusCache[i]) {
+                Chunk chunk = this.chunkCache[i];
+                if (chunk != null || !create) {
+                    return chunk;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    @Unique
+    private Chunk c2me$fastpathExistingChunks(int x, int z, ChunkStatus leastStatus) {
+        final ChunkHolder holder = this.getChunkHolder(ChunkPos.toLong(x, z));
+        if (holder != null) {
+            final CompletableFuture<OptionalChunk<Chunk>> future = holder.load(leastStatus, this.chunkLoadingManager); // thread-safe in new system
+            return future.getNow(ChunkHolder.UNLOADED).orElse(null);
+        }
+        return null;
+    }
+
     @Inject(method = "tick", at = @At(value = "INVOKE", target = "Lnet/minecraft/server/world/ServerChunkManager;updateChunks()Z", shift = At.Shift.AFTER))
     private void updateHolderMapAfterTick(CallbackInfo ci) {
         ((IThreadedAnvilChunkStorage) this.chunkLoadingManager).invokeUpdateHolderMap();
