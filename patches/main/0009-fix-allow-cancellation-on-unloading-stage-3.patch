From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Wed, 25 Dec 2024 22:56:35 +0800
Subject: [PATCH] fix: allow cancellation on unloading stage 3


diff --git a/c2me-rewrites-chunk-system/src/main/java/com/ishland/c2me/rewrites/chunksystem/common/statuses/ReadFromDiskAsync.java b/c2me-rewrites-chunk-system/src/main/java/com/ishland/c2me/rewrites/chunksystem/common/statuses/ReadFromDiskAsync.java
index 47229eb6..851dab8d 100644
--- a/c2me-rewrites-chunk-system/src/main/java/com/ishland/c2me/rewrites/chunksystem/common/statuses/ReadFromDiskAsync.java
+++ b/c2me-rewrites-chunk-system/src/main/java/com/ishland/c2me/rewrites/chunksystem/common/statuses/ReadFromDiskAsync.java
@@ -159,10 +159,6 @@ public class ReadFromDiskAsync extends ReadFromDisk {
                             worldChunk.setLoadedToWorld(false);
                         }
 
-                        if (loadedToWorld.get() && chunk instanceof WorldChunk worldChunk) {
-                            LifecycleEventInvoker.invokeChunkUnload(((IThreadedAnvilChunkStorage) context.tacs()).getWorld(), worldChunk);
-                        }
-
                         if ((context.holder().getFlags() & ItemHolder.FLAG_BROKEN) != 0 && chunk instanceof ProtoChunk) { // do not save broken ProtoChunks
                             LOGGER.warn("Not saving partially generated broken chunk {}", context.holder().getKey());
                             return CompletableFuture.completedStage((Void) null);
@@ -180,7 +176,17 @@ public class ReadFromDiskAsync extends ReadFromDisk {
                     try (var ignored = ThreadInstrumentation.getCurrent().begin(new ChunkTaskWork(context, this, false))) {
                         Chunk chunk = context.holder().getItem().get().chunk();
                         if (chunk instanceof WrapperProtoChunk protoChunk) chunk = protoChunk.getWrappedChunk();
+
+                        if (context.holder().getTargetStatus().ordinal() >= this.ordinal()) { // saving cancelled late
+                            if (chunk instanceof WorldChunk worldChunk) {
+                                worldChunk.setLoadedToWorld(loadedToWorld.get());
+                            }
+                            cancellable.cancel();
+                            throw new CancellationException();
+                        }
+
                         if (loadedToWorld.get() && chunk instanceof WorldChunk worldChunk) {
+                            LifecycleEventInvoker.invokeChunkUnload(((IThreadedAnvilChunkStorage) context.tacs()).getWorld(), worldChunk);
                             ((IThreadedAnvilChunkStorage) context.tacs()).getWorld().unloadEntities(worldChunk);
                         }
 
